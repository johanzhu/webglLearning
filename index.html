<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8">
		<title>小车</title>
		<script type="text/javascript" src="js/cuon-matrix.js" ></script>
	</head>
	<style>
		html,body{
			width: 100%;
			height: 100%;
			overflow: hidden;
			margin: 0;
			padding: 0;
		}
	</style>
	<body>
	</body>
	<script>
		var canvas = document.createElement('canvas'); 
		
		canvas.width = window.innerWidth;
		canvas.height = window.innerHeight;
		document.body.appendChild(canvas);
		
		var gl = canvas.getContext('webgl');
		
		gl.enable(gl.DEPTH_TEST);
		gl.clearColor(0.5,0.5,0.5,1.0);
		gl.clear(gl.COLOR_BUFFER_BIT);
		gl.clearDepth(gl.DEPTH_BITS);
		
		var vertices = [ 
           1.0, 1.0, 1.0,  -1.0, 1.0, 1.0,  -1.0,-1.0, 1.0,   1.0,-1.0, 1.0, 
           1.0, 1.0, 1.0,   1.0,-1.0, 1.0,   1.0,-1.0,-2.0,   1.0, 1.0,-2.0, 
           1.0, 1.0, 1.0,   1.0, 1.0,-2.0,  -1.0, 1.0,-2.0,  -1.0, 1.0, 1.0,
          -1.0, 1.0, 1.0,  -1.0, 1.0,-2.0,  -1.0,-1.0,-2.0,  -1.0,-1.0, 1.0,
          -1.0,-1.0,-2.0,   1.0,-1.0,-2.0,   1.0,-1.0, 1.0,  -1.0,-1.0, 1.0, 
           1.0,-1.0,-2.0,  -1.0,-1.0,-2.0,  -1.0, 1.0,-2.0,   1.0, 1.0,-2.0  
        ];
        
        var normals = [    
           0.0, 0.0, 1.0,   0.0, 0.0, 1.0,   0.0, 0.0, 1.0,   0.0, 0.0, 1.0,  
           1.0, 0.0, 0.0,   1.0, 0.0, 0.0,   1.0, 0.0, 0.0,   1.0, 0.0, 0.0,  
           0.0, 1.0, 0.0,   0.0, 1.0, 0.0,   0.0, 1.0, 0.0,   0.0, 1.0, 0.0, 
          -1.0, 0.0, 0.0,  -1.0, 0.0, 0.0,  -1.0, 0.0, 0.0,  -1.0, 0.0, 0.0,  
           0.0,-1.0, 0.0,   0.0,-1.0, 0.0,   0.0,-1.0, 0.0,   0.0,-1.0, 0.0,  
           0.0, 0.0,-1.0,   0.0, 0.0,-1.0,   0.0, 0.0,-1.0,   0.0, 0.0,-1.0   
        ];
		var indices = [
          0, 1, 2,   0, 2, 3,   
          4, 5, 6,   4, 6, 7,    
          8, 9,10,   8,10,11,    
          12,13,14,  12,14,15,    
          16,17,18,  16,18,19,    
          20,21,22,  20,22,23     
        ];
        
        function torus(row, column, irad, orad){
          var pos = new Array(), nor = new Array(),  
          col = new Array(), idx = new Array();  
          for(var i = 0; i <= row; i++){  
            var r = Math.PI * 2 / row * i;  
            var rr = Math.cos(r);  
            var ry = Math.sin(r);  
            for(var ii = 0; ii <= column; ii++){  
              var tr = Math.PI * 2 / column * ii;  
              var tx = (rr * irad + orad) * Math.cos(tr);  
              var ty = ry * irad;  
              var tz = (rr * irad + orad) * Math.sin(tr);  
              var rx = rr * Math.cos(tr);  
              var rz = rr * Math.sin(tr);  
              pos.push(tx, ty, tz);  
              nor.push(rx, ry, rz);  
            }  
          }  
            for(i = 0; i < row; i++){  
              for(ii = 0; ii < column; ii++){  
                r = (column + 1) * i + ii;  
                idx.push(r, r + column + 1, r + 1);  
                idx.push(r + column + 1, r + column + 2, r + 1);  
              }  
            }  
          return [pos, nor, idx];  
        }  
        
        var torusArray = torus(32,32,0.1,0.4);
        console.log(torusArray);
        
        //圆环
        var torusVertexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER,torusVertexBuffer);
        gl.bufferData(gl.ARRAY_BUFFER,new Float32Array(torusArray[0]),gl.STATIC_DRAW);
        gl.bindBuffer(gl.ARRAY_BUFFER, null);
        
        var torusNormalsBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER,torusNormalsBuffer);
        gl.bufferData(gl.ARRAY_BUFFER,new Float32Array(torusArray[1]),gl.STATIC_DRAW);
        gl.bindBuffer(gl.ARRAY_BUFFER, null);
        
        var torusIndexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER,torusIndexBuffer);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER,new Uint16Array(torusArray[2]),gl.STATIC_DRAW);
        gl.bindBuffer(gl.ARRAY_BUFFER, null);
		
		//立方体
		var vertiesBuffer = gl.createBuffer();
		gl.bindBuffer(gl.ARRAY_BUFFER, vertiesBuffer);
		gl.bufferData(gl.ARRAY_BUFFER,new Float32Array(vertices),gl.STATIC_DRAW);
		gl.bindBuffer(gl.ARRAY_BUFFER, null);
		
		var normalsBuffer = gl.createBuffer();
		gl.bindBuffer(gl.ARRAY_BUFFER, normalsBuffer);
		gl.bufferData(gl.ARRAY_BUFFER,new Float32Array(normals),gl.STATIC_DRAW);
		gl.bindBuffer(gl.ARRAY_BUFFER, null);
		
		var indicesBuffer = gl.createBuffer();
		gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER,indicesBuffer);
		gl.bufferData(gl.ELEMENT_ARRAY_BUFFER,new Uint16Array(indices),gl.STATIC_DRAW);
		gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER,null);
		
		var vertexShader = gl.createShader(gl.VERTEX_SHADER);
		gl.shaderSource(vertexShader,[
		    'precision highp float;',
		    '',
		    'attribute vec3 a_Position;',
		    'attribute vec4 a_Color;',
		    'attribute vec3 a_Normal;',
		    'varying vec4 v_Color;',
		    'uniform mat4 u_MvpMatrix;',
		    'uniform vec3 u_LightColor;',
		    'uniform vec3 u_LightDirection;',
		    'uniform vec3 u_Ambient;',
		    'void main() {',	
		      'gl_Position = u_MvpMatrix * vec4(a_Position,1.0);',
		      'vec3 normal = normalize(a_Normal.xyz);',
		      'float nDotL = max(dot( u_LightDirection, normal ), 0.0);',
		      'vec3 diffuse = u_LightColor * vec3(a_Color) * nDotL;',
		      'vec3 ambient = u_Ambient * a_Color.rgb;',
		      'v_Color = vec4(diffuse + ambient , 1.0);',
		    '}'
		].join('\n'));
		gl.compileShader(vertexShader);
		
		var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
		gl.shaderSource(fragmentShader,[
	        'precision highp float;',
		    '',
		    'varying vec4 v_Color;',
		    'void main() {',
		      'gl_FragColor = v_Color;',
		    '}'
		].join('\n'));
		gl.compileShader(fragmentShader);
		
		var program = gl.createProgram();
		gl.attachShader(program,vertexShader);
		gl.attachShader(program,fragmentShader);
		gl.linkProgram(program);
		gl.useProgram(program);
		
		if(!gl.getProgramParameter(program,gl.LINK_STATUS)){
          console.log("Couldnotinitialiseshaders");
          console.log(gl.LINK_STATUS);
        }
		if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
          console.log(gl.getShaderInfoLog(vertexShader));
        } 
        if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
          console.log(gl.getShaderInfoLog(fragmentShader));
        }
		//MVP矩阵
		var u_MvpMatrix = gl.getUniformLocation(program, 'u_MvpMatrix');
		var mvpMatrix = new Matrix4();   
        mvpMatrix.setPerspective(30, canvas.width/canvas.height, 1, 100);
        mvpMatrix.lookAt(8, 5, 7, 0, 0, 0, 0, 1, 0);
        gl.uniformMatrix4fv(u_MvpMatrix, false, mvpMatrix.elements);
		
		//光参数
		var u_LightColor = gl.getUniformLocation(program,'u_LightColor');
		gl.uniform3f(u_LightColor,1.0,1.0,1.0);
		
		var lightDirection = new Vector3([0.0,0.0,5.0]);
		lightDirection.normalize();
		var u_LightDirection = gl.getUniformLocation(program,'u_LightDirection');
		gl.uniform3fv(u_LightDirection,lightDirection.elements);
		
		var u_Ambient = gl.getUniformLocation(program,'u_Ambient');
		gl.uniform3f(u_Ambient, 0.2,0.2,0.2);
		
		//基色
		var a_Color = gl.getAttribLocation(program, 'a_Color');
		gl.vertexAttrib4f(a_Color, 1.0,0.0,0.0,1.0);
		
		//画车身
		gl.bindBuffer(gl.ARRAY_BUFFER, vertiesBuffer);
		gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER,indicesBuffer);
		var a_Position = gl.getAttribLocation(program,'a_Position');
		gl.enableVertexAttribArray(a_Position);
		gl.vertexAttribPointer( a_Position, 3, gl.FLOAT, false, 0, 0);
		
		//立方体法线
		gl.bindBuffer(gl.ARRAY_BUFFER, torusNormalsBuffer);
		var a_Normal = gl.getAttribLocation(program,'a_Normal');
		gl.enableVertexAttribArray(a_Normal);
		gl.vertexAttribPointer( a_Normal, 3, gl.FLOAT, false, 0, 0);
		
		gl.drawElements(gl.TRIANGLES,indices.length,gl.UNSIGNED_SHORT,0);
		
		//画轮胎
		gl.bindBuffer(gl.ARRAY_BUFFER, torusVertexBuffer);
		gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER,torusIndexBuffer);
		var a_Position = gl.getAttribLocation(program,'a_Position');
		gl.enableVertexAttribArray(a_Position);
		gl.vertexAttribPointer( a_Position, 3, gl.FLOAT, false, 0, 0);
		
		mvpMatrix.translate(0.5,-1.5,0);
		mvpMatrix.rotate(90,0,0,1);
        gl.uniformMatrix4fv(u_MvpMatrix, false, mvpMatrix.elements);
		gl.drawElements(gl.TRIANGLES,torusArray[2].length,gl.UNSIGNED_SHORT,0);
		
		mvpMatrix.setIdentity();
		mvpMatrix.setPerspective(30, canvas.width/canvas.height, 1, 100);
        mvpMatrix.lookAt(8, 5, 7, 0, 0, 0, 0, 1, 0);
        mvpMatrix.translate(-1.8,-1.5,0);
		mvpMatrix.rotate(90,0,0,1);
		gl.uniformMatrix4fv(u_MvpMatrix, false, mvpMatrix.elements);
		gl.drawElements(gl.TRIANGLES,torusArray[2].length,gl.UNSIGNED_SHORT,0);
		
		mvpMatrix.setIdentity();
		mvpMatrix.setPerspective(30, canvas.width/canvas.height, 1, 100);
        mvpMatrix.lookAt(8, 5, 7, 0, 0, 0, 0, 1, 0);
        mvpMatrix.translate(-1.8,-1.5,-2.3);
		mvpMatrix.rotate(90,0,0,1);
		gl.uniformMatrix4fv(u_MvpMatrix, false, mvpMatrix.elements);
		gl.drawElements(gl.TRIANGLES,torusArray[2].length,gl.UNSIGNED_SHORT,0);
		
		mvpMatrix.setIdentity();
		mvpMatrix.setPerspective(30, canvas.width/canvas.height, 1, 100);
        mvpMatrix.lookAt(8, 5, 7, 0, 0, 0, 0, 1, 0);
        mvpMatrix.translate(0.5,-1.5,-2.3);
		mvpMatrix.rotate(90,0,0,1);
		gl.uniformMatrix4fv(u_MvpMatrix, false, mvpMatrix.elements);
		gl.drawElements(gl.TRIANGLES,torusArray[2].length,gl.UNSIGNED_SHORT,0);
		
	</script>
</html>
